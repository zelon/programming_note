# programming_note

* 클래스 이름과 인터페이스를 보고 그 클래스가 하는 일을 쉽게 알 수 있어야 한다
* SOLID 원칙
* 객체의 관계를 이용해서 복잡한 생명주기 문제를 풀 수 있다
* 코드의 컨셉을 잡고 컨셉이 깨지지 않도록 유지해야 한다. 어쩔 수 없이 깨어졌다면 다시 설계해야 한다. 놓아두면 스파게티 코드, 이해하기 힘든 코드가 된다.
* 컨셉을 잘 잡아야 하고, 컨셉을 잘 드러나게 이름을 잘 지어야 한다
* 구조, 설계를 바꿀 때는 컨셉을 잡고 그려보고 바꿔라. 핸들러 상속구조를 포기하고 콜백오버라이드 구조로 간다와 같이.
* 문제를 해결할 때는 최초의 해결책 발견 시의 흥분으로 맹목적으로 그 해결책을 채택해서는 안된다
* 기존 코드를 억지로 이용하려고 하면 어그리게이션된다
* 로그를 남길 때는 로그가 발생했을 때 알아보기 쉽게 추적하기 해야 한다. 코드에서 검색했을 때 한번에 나오도록 한다. 유니크값을 항상 적어서 앞뒤 로그를 추적하기 쉽게 한다.
* 모델로 따로 빼내는 이유는 코드가 복잡해져서 컨트롤러로 여러개로 분할되었기 때문에 여러 컨트롤러에서 모델을 참조하기 때문이다. 모델은 내부를 잘 드러나게 짜도 괜찮다
* 모델과 컨트롤러로 나누어 짜면 얼핏 보기에 코드가 2벌이 되기 때문에 복잡해져 보일 수 있지만, 모델은 단순한 자료구조를 가지도록 만들고, 컨트롤러는 그 자료구조를 잘 활용하는 형태로 짜버리면, 자료구조 코드가 컨트롤러에는 없기 때문에 컨트롤러 코드량이 줄어서 컨트롤러만 이해하기 쉬워진다. 양쪽의 코드를 따로따로 읽어도 잘 읽히게 된다
* 설계의 확신과 강단이 있어야 한다


# 좋은 글들
 * [http://woowabros.github.io/study/2018/03/05/sdp-sap.html]: 안정된 의존관계 원칙과 안정된 추상화 원칙에 대하여, 추상성과 안정성을 2개의 축으로 해서, 코드의 위치를 판단해본다. 의존성이 높을 수록 안정적인 코드이며, 추상성이 필요하다.
